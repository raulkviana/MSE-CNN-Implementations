\chapter{MSE-\/\+CNN Implementation}
\hypertarget{index}{}\label{index}\index{MSE-\/CNN Implementation@{MSE-\/CNN Implementation}}
\label{index_md_pages__doxygen_2mainpage}%
\Hypertarget{index_md_pages__doxygen_2mainpage}%
   

Code database with an implementation of MSE-\/\+CNN \mbox{[}1\mbox{]}. Besides the code, the dataset and coefficients obtained after training are provided.


\begin{DoxyCode}{0}
\DoxyCodeLine{>>>\ \textcolor{keyword}{import}\ torch}
\DoxyCodeLine{>>>\ \textcolor{keyword}{import}\ msecnn}
\DoxyCodeLine{>>>\ \textcolor{keyword}{import}\ train\_model\_utils}
\DoxyCodeLine{>>>}
\DoxyCodeLine{>>>\ \textcolor{comment}{\#\ Initialize\ parameters}}
\DoxyCodeLine{>>>\ path\_to\_folder\_with\_model\_params\ =\ \textcolor{stringliteral}{"{}model\_coefficients/best\_coefficients"{}}}
\DoxyCodeLine{>>>\ device\ =\ \textcolor{stringliteral}{"{}cuda:0"{}}}
\DoxyCodeLine{>>>\ qp\ =\ 32\ \ \textcolor{comment}{\#\ Quantisation\ Parameter}}
\DoxyCodeLine{>>>\ }
\DoxyCodeLine{>>>\ \textcolor{comment}{\#\ Initialize\ Model}}
\DoxyCodeLine{>>>\ stg1\_2\ =\ msecnn.MseCnnStg1(device=device,\ QP=qp).to(device)}
\DoxyCodeLine{>>>\ stg3\ =\ msecnn.MseCnnStgX(device=device,\ QP=qp).to(device)}
\DoxyCodeLine{>>>\ stg4\ =\ msecnn.MseCnnStgX(device=device,\ QP=qp).to(device)}
\DoxyCodeLine{>>>\ stg5\ =\ msecnn.MseCnnStgX(device=device,\ QP=qp).to(device)}
\DoxyCodeLine{>>>\ stg6\ =\ msecnn.MseCnnStgX(device=device,\ QP=qp).to(device)}
\DoxyCodeLine{>>>\ model\ =\ (stg1\_2,\ stg3,\ stg4,\ stg5,\ stg6)}
\DoxyCodeLine{>>>}
\DoxyCodeLine{>>>\ model\ =\ train\_model\_utils.load\_model\_parameters\_eval(model,\ path\_to\_folder\_with\_model\_params,\ device)}
\DoxyCodeLine{>>>}
\DoxyCodeLine{>>>\ \textcolor{comment}{\#\ Loss\ function}}
\DoxyCodeLine{>>>\ loss\_fn\ =\ msecnn.LossFunctionMSE()}
\DoxyCodeLine{>>>\ }
\DoxyCodeLine{>>>\ \textcolor{comment}{\#\ Path\ to\ labels}}
\DoxyCodeLine{>>>\ l\_path\_val\ =\ \textcolor{stringliteral}{"{}example\_data/stg2"{}}}
\DoxyCodeLine{>>>}
\DoxyCodeLine{>>>\ \textcolor{comment}{\#\ Random\ CTU\ and\ labels}}
\DoxyCodeLine{>>>\ CTU\ =\ torch.rand(1,\ 1,\ 128,\ 128).to(device)}
\DoxyCodeLine{>>>\ CTU}
\DoxyCodeLine{tensor([[[[0.9320,\ 0.6777,\ 0.4490,\ \ ...,\ 0.0413,\ 0.6278,\ 0.5375],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ [0.3544,\ 0.5620,\ 0.8339,\ \ ...,\ 0.6420,\ 0.2527,\ 0.3104],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ [0.0555,\ 0.4991,\ 0.9972,\ \ ...,\ 0.3898,\ 0.1169,\ 0.1661],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ ...,}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ [0.9452,\ 0.3566,\ 0.9825,\ \ ...,\ 0.3941,\ 0.7534,\ 0.8656],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ [0.3839,\ 0.8459,\ 0.4369,\ \ ...,\ 0.9569,\ 0.2609,\ 0.6421],}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ [0.1734,\ 0.7182,\ 0.8074,\ \ ...,\ 0.2122,\ 0.7573,\ 0.2492]]]])}
\DoxyCodeLine{>>>\ cu\_pos\ =\ torch.tensor([[0,\ 0]]).to(device)}
\DoxyCodeLine{>>>\ cu\_size\ =\ torch.tensor([[64,\ 64]]).to(device)\ \ \textcolor{comment}{\#\ Size\ of\ the\ CU\ of\ the\ second\ stage}}
\DoxyCodeLine{>>>\ split\_label\ =\ torch.tensor([[1]]).to(device)}
\DoxyCodeLine{>>>\ RDs\ =\ torch.rand(1,\ 6).to(device)\ *\ 10\_000}
\DoxyCodeLine{>>>\ RDs}
\DoxyCodeLine{tensor([[1975.6646,\ 2206.7600,\ 1570.3577,\ 3570.9478,\ 6728.2612,\ \ 527.9994]])}
\DoxyCodeLine{>>>\ \textcolor{comment}{\#\ Compute\ prediction\ for\ stages\ 1\ and\ 2}}
\DoxyCodeLine{>>>\ \textcolor{comment}{\#\ Stage\ 1\ and\ 2}}
\DoxyCodeLine{>>>\ pred1\_2,\ CUs,\ ap\ =\ model[0](CTU,\ cu\_size,\ cu\_pos)\ \ \textcolor{comment}{\#\ Pass\ CU\ through\ network}}
\DoxyCodeLine{>>>\ pred1\_2}
\DoxyCodeLine{tensor([[9.9982e-\/01,\ 1.8124e-\/04,\ 9.9010e-\/21,\ 5.9963e-\/29,\ 1.9118e-\/24,\ 1.0236e-\/25]],}
\DoxyCodeLine{\ \ \ \ \ \ \ grad\_fn=<SoftmaxBackward0>)}
\DoxyCodeLine{>>>\ CUs.shape}
\DoxyCodeLine{torch.Size([1,\ 16,\ 64,\ 64])}
\DoxyCodeLine{>>>\ }
\DoxyCodeLine{>>>\ \textcolor{comment}{\#\ Compute\ the\ loss}}
\DoxyCodeLine{>>>\ loss,\ loss\_CE,\ loss\_RD\ =\ loss\_fn(pred1\_2,\ split\_label,\ RDs)}
\DoxyCodeLine{>>\ loss}
\DoxyCodeLine{tensor(177.1340,\ grad\_fn=<AddBackward0>)}
\DoxyCodeLine{>>\ loss\_CE}
\DoxyCodeLine{tensor(174.3921,\ grad\_fn=<NegBackward0>)}
\DoxyCodeLine{>>\ loss\_RD}
\DoxyCodeLine{tensor(2.7419,\ grad\_fn=<MeanBackward1>)}

\end{DoxyCode}



\begin{DoxyItemize}
\item MSE-\/\+CNN Implementation
\begin{DoxyItemize}
\item 1. Introduction
\item 2. Theorectical Background
\begin{DoxyItemize}
\item 2.1 Partitioning in VVC
\item 2.2 MSE-\/\+CNN
\begin{DoxyItemize}
\item 2.2.1 Architecture
\item 2.2.2 Loss Function
\item 2.2.3 Training
\item 2.2.4 Implementation remarks
\end{DoxyItemize}
\end{DoxyItemize}
\item 3. Dataset
\item 4. Results
\begin{DoxyItemize}
\item 4.1 F1-\/score, Recall and Precision with test data
\item 4.2 Confusion matrices
\begin{DoxyItemize}
\item 4.2.1 Stages 2 and 3
\item 4.2.2 Stages 4 and 5
\item 4.2.3 Stage 6
\end{DoxyItemize}
\item 4.3 Y-\/\+PSNR, Complexity Reduction and Bitrate with test data
\end{DoxyItemize}
\item 5. Relevant Folders and files
\begin{DoxyItemize}
\item 5.1 Folders
\item 5.2 Files in src folder
\end{DoxyItemize}
\item 6. Installation of dependencies
\begin{DoxyItemize}
\item Requirements
\item Package Distributions
\end{DoxyItemize}
\item 7. Contributions
\item 8. License
\item 9. TODO
\item 10. References
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{index_autotoc_md4}{}\doxysection{\texorpdfstring{1. Introduction}{1. Introduction}}\label{index_autotoc_md4}
The emergence of new technologies that provide creative audiovisual experiences, such as 360-\/degree films, virtual reality, augmented reality, 4K, 8K UHD, 16K, and also with the rise of video traffic on the web, shows the current demand for video data in the modern world. Because of this tension, Versatile Video Coding (VVC) was developed due to the the necessity for the introduction of new coding standards. Despite the advancements achieved with the introduction of this standard, its complexity has increased very much. The new partitioning technique is responsible for majority of the increase in encoding time. This extended duration is linked with the optimization of the Rate-\/\+Distortion cost (RD cost). Although VVC offers higher compression rates, the complexity of its encoding is high.

  

Fig. 1\+: VVC Complexity

 

In light of this, the Multi-\/\+Stage Exit Convolutional Neural Nework (MSE-\/\+CNN) was developed. This Deep Learning-\/based model is organised in a sequential structure with several stages. Each stage, which represents a different partition depth, encompasses a set of layers for extracting features from a Coding Tree Unit (CTU) and deciding how to partition it. Instead of using recursive approaches to determine the optimal way to fragment an image, this model allows VVC to estimate the most appropriate way of doing it. {\bfseries{This work presents a model of the MSE-\/\+CNN that employs training procedures distinct from the original implementation of this network, as well as the ground-\/thruth to train and validate the model and an interpretation of the work done by the MSE-\/\+CNN’s original creators}}.

  

Fig. 2\+: MSE-\/\+CNN benefits

 \hypertarget{index_autotoc_md5}{}\doxysection{\texorpdfstring{2. Theorectical Background}{2. Theorectical Background}}\label{index_autotoc_md5}
\hypertarget{index_autotoc_md6}{}\doxysubsection{\texorpdfstring{2.\+1 Partitioning in VVC}{2.1 Partitioning in VVC}}\label{index_autotoc_md6}
The key objective of partitioning is to divide frames into pieces in a way that results in a reduction of the RD cost. To achieve a perfect balance of quality and bitrate, numerous image fragments combinations must be tested, which is computationally expensive. Due to the intensive nature of this process, a high compression rate can be attained. Partitioning contributes heavily to both the complexity and compression gains in VVC. H.\+266 (VVC), organize a video sequence in many frames that are divided into smaller pieces. First, pictures are split into coding tree units (CTUs), and then they are divided into coding units (CUs). For the luma channel, the largest CTU size in VVC is 128x128 and the smallest is 4x4. In VVC, a quad-\/tree (QT) is initially applied to the CTUs in the first level, and then a quad-\/tree with nested multi-\/type tree (QMTT) is applied recursively.

  

Fig. 3\+: Types of partitions in VVC

 

This innovation makes it possible to split CUs in different rectangle forms. Splitting a CU into\+:


\begin{DoxyItemize}
\item three rectangles with a ratio of 1\+:2\+:1 results in a ternary tree (TT), with the center rectangle being half the size of the original CU; when applied horizontally it is called a horizontal ternary tree (HTT), and vertical ternary tree (VTT) when it is done vertically.
\item two rectangles results in a binary tree (BT)partition, a block with two symmetrical structures; like in the case of the TT, depending on the way the split is done, it can be called either a vertical binary tree (VBT) or a horizontal binary tree (HBT).
\end{DoxyItemize}

The association of BT and TT is named a multi-\/type tree (MTT). The introduction of BT and TT partitions enables the creation of various new types of forms, with heights and widths that can be a combination between 128, 64, 32, 16, 8 and 4. The increased number of possible CUs boosts the ability of the codec to fragment an image more efficiently, allowing better predictions and higher compressing abilities. Although this standard now have these advantages, as a downside it takes longer to encode.

  

Fig. 4\+: Partitioning in VVC

 \hypertarget{index_autotoc_md7}{}\doxysubsection{\texorpdfstring{2.\+2 MSE-\/\+CNN}{2.2 MSE-CNN}}\label{index_autotoc_md7}
Multi-\/\+Stage Exit Convolutional Neural Network (MSE-\/\+CNN) is a DL model that seeks to forecast CUs in a waterfall architecture (top-\/down manner), it integrates . This structure takes a CTU as input, extracts features from it, splits the CU into one of at most six possible partitions (Non-\/split, QT, HBT, VBT, HTT, and VTT), and then sends it to the next stage. This model has CTUs as inputs in the first stage, either in the chroma or luma channel, and feature maps in the subsequent stages. Furthermore, it generates feature maps and a split decision at each level. In the event that one of the models returns the split decision as Non-\/\+Split, the partitioning of the CU is ended immediately.

{\bfseries{Note}}\+: Details about how to load model coefficients can be found \doxysectlink{md_pages__doxygen_2modelcoefpage}{here}{0}.\hypertarget{index_autotoc_md8}{}\doxysubsubsection{\texorpdfstring{2.\+2.\+1 Architecture}{2.2.1 Architecture}}\label{index_autotoc_md8}
This model is composed by the following blocks\+:


\begin{DoxyItemize}
\item Initially, this model adds more channels to the input of this network to create more features from it; this is accomplished by utilising simple convolutional layers.
\end{DoxyItemize}

  

Fig. 5\+: Overlapping convolution layer

 


\begin{DoxyItemize}
\item To extract more characteristics from the data, the information is then passed through a series of convolutional layers; these layers were named Conditional Convolution.
\end{DoxyItemize}

  

Fig. 6\+: Conditional Convolution

 


\begin{DoxyItemize}
\item At the end, a final layer is employed to determine the optimal manner of partitioning the CU. This layer is a blend of fully connected and convolutional layers.
\end{DoxyItemize}

  

Fig. 7\+: Sub-\/networks

 

Note\+: For more details regarding these layers check \mbox{[}1\mbox{]}\hypertarget{index_autotoc_md9}{}\doxysubsubsection{\texorpdfstring{2.\+2.\+2 Loss Function}{2.2.2 Loss Function}}\label{index_autotoc_md9}
The loss developed for the MSE-\/\+CNN is the result of two other functions, as defined in the following expression\+:

\$\$ L = L\+\_\+\{CE\}+\textbackslash{}beta L\+\_\+\{RD\}\$\$

In the above equation, \$\textbackslash{}beta\$ is a real number to adjust the influence of the \$\+L\+\_\+\{RD\}\$ loss. The first member of this loss function is a modified Cross-\/\+Entrotopy loss, developed to solve imbalanced dataset issues\+:

\$\$\+L\+\_\+\{CEmod\} = -\/\textbackslash{}frac\{1\}\{N\}\textbackslash{}sum\+\_\+\{n=1\}\texorpdfstring{$^\wedge$}{\string^}N \textbackslash{}sum\+\_\+\{m\textbackslash{}varepsilon Partitions\}(\textbackslash{}frac\{1\}\{p\+\_\+m\})\texorpdfstring{$^\wedge$}{\string^}\textbackslash{}alpha y\+\_\+\{n, m\}\textbackslash{}log(\textbackslash{}hat\{y\}\+\_\+\{n, m\})\$\$

 \textsubscript{ Eq. 1\+: In this equation \"{}n\"{} is the batch number, \"{}m\"{} is the corresponding partition (0 (Non-\/\+Split), 1 (QT), 2 (HBT), 3 (VBT), 4 (VTT), 5 (HTT)), \"{}\+N\"{} is the total number of batches and alpha is a parameter to configure the penalties for the less represented classes } 

~\newline
 ~\newline


Concerning the second member of the MSE-\/\+CNN loss function, this constituent gives the network the ability to also make predictions based on the RD Cost.

\$\$\+L\+\_\+\{RD\} = \textbackslash{}frac\{1\}\{N\}\textbackslash{}sum\+\_\+\{n=1\}\texorpdfstring{$^\wedge$}{\string^}N \textbackslash{}sum\+\_\+\{m\textbackslash{}varepsilon Partitions\}\textbackslash{}hat\{y\}\+\_\+\{n, m\}\textbackslash{}frac\{r\+\_\+\{n, m\}\}\{r\+\_\+\{n, min\}\}-\/1\$\$

In the above equation, the RD costs \$r\+\_\+\{n, m\}\$ uses the same notation for \"{}n\"{} and \"{}m\"{} as the previous equation. Regarding \$r\+\_\+\{n ,min\}\$, it is the minimal RD cost for the nth CU among all split modes and \$\$\textbackslash{}frac\{r\+\_\+\{n, m\}\}\{r\+\_\+\{n, min\}\} -\/ 1\$\$ is a normalised RD cost. As a relevant note, \$r\+\_\+\{n, min\}\$ is equal to the RD cost of the best partition mode. Consequently, the result of

  

ensures that CU\textquotesingle{}s partitions with greater erroneously predicted probability values or greater RD cost values \$r\+\_\+\{n, m\}\$ are more penalised. In \$\textbackslash{}frac\{r\+\_\+\{n, m\}\}\{r\+\_\+\{n, min\}\} -\/ 1\$, the ideal partition has a normalised RD cost of zero, but the other partitions do not. Therefore, the only way for the loss to equal zero is if the probability for all other modes also equals zero. Consequently, the learning algorithm must assign a greater probability to the optimal split mode while reducing the probabilities for the rest. {\bfseries{Experimentally it was verified that this function wasn\textquotesingle{}t able to contribute to the training of the MSE-\/\+CNN, this contradicted the remarks made in \mbox{[}1\mbox{]}}}.\hypertarget{index_autotoc_md10}{}\doxysubsubsection{\texorpdfstring{2.\+2.\+3 Training}{2.2.3 Training}}\label{index_autotoc_md10}
The strategy used to train the MSE-\/\+CNN was very similar to the one used in \mbox{[}1\mbox{]}. The first parts of the model to be trained were the first and second stages, in which 64x64 CUs were passed through the second depth. Afterwards, transfer learning was used to pass certain coefficients of the second stage to the third. Then, the third stage was trained with 32x32 CUs flowing through it. After this step, a similar process was done to the following stages. It is worth noting that, beginning with stage 4, various CUs forms are at the models\textquotesingle{} input. This means that these stages were fed different kinds of CUs. ~\newline


  

Fig. 8\+: Training flow used

 

At the end of training, 6 models were obtained one for each partitioning depth in the luma channel. Although models for the luma and chroma channels could be created for all the shapes of CUs that are possible, rather than just for each depth, only six were trained for the sake of assessing the model behaviour in a simpler and more understandable configuration.\hypertarget{index_autotoc_md11}{}\doxysubsubsection{\texorpdfstring{2.\+2.\+4 Implementation remarks}{2.2.4 Implementation remarks}}\label{index_autotoc_md11}
Due to the deterministic nature of the first stage, where CTUs are always partitioned with a QT, it was implemented together with the second stage. If it was done separately, the training for the first two stages would have to be done at the same time. Consequently, two distinct optimisers would need to be employed, which could result in unpredictable training behaviour. ~\newline


   

Fig. 9\+: 32 minimum axis size sub-\/networks

 

When implementing the sub-\/networks on code, those that were meant to cater for varying CU sizes were further implemented separately. For example, in the case of the sub-\/network utilised when the minimum width or height is 32, two variants of the first two layers were built. This was done because 64x32 and 32x32 CUs can flow across this block. Because of this, the first two layers were implemented separately from the entire block. Then, they were used in conjunction with the remaining layers based on the dimensions of the input CU. The same procedures were followed for the other types of sub-\/networks.

When the network was being trained, some of the RD costs from the input data had very high values. Consequently, the RD loss function value skyrocketed, resulting in extremely huge gradients during training. As a result, the maximum RD cost was hard coded at \$10\texorpdfstring{$^\wedge$}{\string^}\{10\}\$. This amount is large enough to be more than the best partition\textquotesingle{}s RD cost and small enough to address this issue.\hypertarget{index_autotoc_md12}{}\doxysection{\texorpdfstring{3. Dataset}{3. Dataset}}\label{index_autotoc_md12}
Please see this \doxysectlink{md_pages__doxygen_2dataset}{page}{0} to understand better the dataset and also access it. To see example data go to follow \doxysectlink{md_pages__doxygen_2exampledatapage}{this}{0}.\hypertarget{index_autotoc_md13}{}\doxysection{\texorpdfstring{4. Results}{4. Results}}\label{index_autotoc_md13}
Since it was verified that the Rate-\/\+Distortion Loss. \$\+L\+\_\+\{RD\}\$, could contribute for better results, the metrics presented here were obtained with a model trained only with the modified cross-\/entropy loss.\hypertarget{index_autotoc_md14}{}\doxysubsection{\texorpdfstring{4.\+1 F1-\/score, Recall and Precision with test data}{4.1 F1-score, Recall and Precision with test data}}\label{index_autotoc_md14}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Stage   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ F1-\/\+Score   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Recall   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Precision    }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Stage   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ F1-\/\+Score   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Recall   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Precision    }\\\cline{1-4}
\endhead
Stage 2   &0.\+9111   &0.\+9111   &0.\+9112    \\\cline{1-4}
Stage 3   &0.\+5624   &0.\+5767   &0.\+5770    \\\cline{1-4}
Stage 4   &0.\+4406   &0.\+4581   &0.\+4432    \\\cline{1-4}
Stage 5   &0.\+5143   &0.\+5231   &0.\+5184    \\\cline{1-4}
Stage 6   &0.\+7282   &0.\+7411   &0.\+7311   \\\cline{1-4}
\end{longtabu}


Results with weighted average for F1-\/score, recall and precision.\hypertarget{index_autotoc_md15}{}\doxysubsection{\texorpdfstring{4.\+2 Confusion matrices}{4.2 Confusion matrices}}\label{index_autotoc_md15}
\hypertarget{index_autotoc_md16}{}\doxysubsubsection{\texorpdfstring{4.\+2.\+1 Stages 2 and 3}{4.2.1 Stages 2 and 3}}\label{index_autotoc_md16}
   

Fig. 10\+: Confusion matrix results with the testing data in stages 2 and 3

 \hypertarget{index_autotoc_md17}{}\doxysubsubsection{\texorpdfstring{4.\+2.\+2 Stages 4 and 5}{4.2.2 Stages 4 and 5}}\label{index_autotoc_md17}
   

Fig. 11\+: Confusion matrix results with the testing data in stages 4 and 5

 \hypertarget{index_autotoc_md18}{}\doxysubsubsection{\texorpdfstring{4.\+2.\+3 Stage 6}{4.2.3 Stage 6}}\label{index_autotoc_md18}
  

Fig. 12\+: Confusion matrix results with the testing data in stage 6

 \hypertarget{index_autotoc_md19}{}\doxysubsection{\texorpdfstring{4.\+3 Y-\/\+PSNR, Complexity Reduction and Bitrate with test data}{4.3 Y-PSNR, Complexity Reduction and Bitrate with test data}}\label{index_autotoc_md19}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Metric   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ VTM-\/7.\+0   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ VTM-\/7.\+0+Model   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Gain    }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Metric   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ VTM-\/7.\+0   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ VTM-\/7.\+0+Model   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Gain    }\\\cline{1-4}
\endhead
Bitrate   &3810.\+192 kbps   &4069.\+392 kbps   &6.\+80\%    \\\cline{1-4}
Y-\/\+PSNR   &35.\+7927 dB   &35.\+5591 dB   &-\/0.\+65\%    \\\cline{1-4}
Complexity   &1792.\+88 s   &1048.\+95 s   &-\/41.\+49\%   \\\cline{1-4}
\end{longtabu}


{\bfseries{These results were obtained with the \"{}medium\"{} configuration for the multi-\/thresholding method.}}\hypertarget{index_autotoc_md20}{}\doxysection{\texorpdfstring{5. Relevant Folders and files}{5. Relevant Folders and files}}\label{index_autotoc_md20}
\hypertarget{index_autotoc_md21}{}\doxysubsection{\texorpdfstring{5.\+1 Folders}{5.1 Folders}}\label{index_autotoc_md21}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Folder   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Folder   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endhead
\href{/dataset}{\texttt{ dataset}}   &This folder contains all of the dataset and all of the data that was processed in order to obtain it    \\\cline{1-2}
\href{/example_data}{\texttt{ example\+\_\+data}}   &Here you can find some example data that it is used for the scripts in usefull\+\_\+scripts folder    \\\cline{1-2}
\href{/model_coefficients}{\texttt{ model\+\_\+coefficients}}   &The last coefficient obtained during training, as well as the best one in terms of the best F1-\/score obtained in testing data    \\\cline{1-2}
\href{/src}{\texttt{ src}}   &Source code with the implementation of the MSE-\/\+CNN and also useful code and examples   \\\cline{1-2}
\end{longtabu}
\hypertarget{index_autotoc_md22}{}\doxysubsection{\texorpdfstring{5.\+2 Files in src folder}{5.2 Files in src folder}}\label{index_autotoc_md22}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Files   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Files   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description    }\\\cline{1-2}
\endhead
\doxylink{constants_8py}{constants.\+py}   &Constant values used in other python files    \\\cline{1-2}
\doxylink{custom__dataset_8py}{custom\+\_\+dataset.\+py}   &Dataset class to handle the files with the ground-\/thruth information, as well as other usefull classes to work together with the aforementioned class    \\\cline{1-2}
\doxylink{dataset__utils_8py}{dataset\+\_\+utils.\+py}   &Functions to manipulate and process the data, also contains functions to interact with YUV files    \\\cline{1-2}
\doxylink{msecnn_8py}{msecnn.\+py}   &MSE-\/\+CNN and Loss Function classes implementation    \\\cline{1-2}
\doxylink{train__model__utils_8py}{train\+\_\+model\+\_\+utils.\+py}   &Usefull functions to be used during training or evaluation of the artificial neural network    \\\cline{1-2}
\doxylink{utils_8py}{utils.\+py}   &Other functions that are usefull not directly to the model but for the code implementation itself   \\\cline{1-2}
\end{longtabu}
\hypertarget{index_autotoc_md23}{}\doxysection{\texorpdfstring{6. Installation of dependencies}{6. Installation of dependencies}}\label{index_autotoc_md23}
In order to explore this project, it is needed to first install of the libraries used in it.\hypertarget{index_autotoc_md24}{}\doxysubsection{\texorpdfstring{Requirements}{Requirements}}\label{index_autotoc_md24}
For this please follow the below steps\+:
\begin{DoxyEnumerate}
\item Create a virtual environment to do install the libraries; follow this \href{https://www.geeksforgeeks.org/creating-python-virtual-environment-windows-linux/}{\texttt{ link}} in case you don\textquotesingle{}t know how to do it; you possibly need to install \href{https://www.makeuseof.com/tag/install-pip-for-python/}{\texttt{ pip}}, if you don\textquotesingle{}t have it installed
\item Run the following command\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{pip\ install\ -\/r\ requirements.txt}

\end{DoxyCode}
 This will install all of the libraries references in the requirements.\+txt file.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item When you have finished using the package or working on your project, you can deactivate the virtual environment\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{deactivate}

\end{DoxyCode}
 This command exits the virtual environment and returns you to your normal command prompt.
\end{DoxyEnumerate}
\begin{DoxyEnumerate}
\item Enjoy! \+:)
\end{DoxyEnumerate}\hypertarget{index_autotoc_md25}{}\doxysubsection{\texorpdfstring{Package Distributions}{Package Distributions}}\label{index_autotoc_md25}

\begin{DoxyEnumerate}
\item Locate the {\ttfamily dist} folder in your project\textquotesingle{}s root directory. This folder contains the package distributions, including the source distribution ({\ttfamily \texorpdfstring{$\ast$}{*}.tar.\+gz} file) and the wheel distribution ({\ttfamily \texorpdfstring{$\ast$}{*}.whl} file).
\item Install the package using one of the following methods\+:
\begin{DoxyItemize}
\item Install the source distribution\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{pip\ install\ dist/msecnn\_raulkviana-\/1.0.tar.gz}

\end{DoxyCode}

\item Install the wheel distribution\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{pip\ install\ dist/msecnn\_raulkviana-\/1.0.whl}

\end{DoxyCode}

\end{DoxyItemize}
\item Once the package is installed, you can import and use its functionalities in your Python code.
\end{DoxyEnumerate}\hypertarget{index_autotoc_md26}{}\doxysection{\texorpdfstring{7. Contributions}{7. Contributions}}\label{index_autotoc_md26}
Feel free to contact me through this \href{raulviana@ua.pt}{\texttt{ email}} or create either a issue or pull request to contribute to this project \texorpdfstring{$^\wedge$}{\string^}\texorpdfstring{$^\wedge$}{\string^}.\hypertarget{index_autotoc_md27}{}\doxysection{\texorpdfstring{8. License}{8. License}}\label{index_autotoc_md27}
This project license is under the \mbox{[}MIT License\mbox{]}(LICENSE).\hypertarget{index_autotoc_md28}{}\doxysection{\texorpdfstring{9. TODO}{9. TODO}}\label{index_autotoc_md28}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Task   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Status (d -\/ doing, w -\/ waiting, f-\/ finished)    }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Task   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Description   }&\PBS\centering \cellcolor{\tableheadbgcolor}\textbf{ Status (d -\/ doing, w -\/ waiting, f-\/ finished)    }\\\cline{1-3}
\endhead
Implement code to test functions   &Use a library, such as Pytest, to test some functions from the many modules developed   &w   \\\cline{1-3}
\end{longtabu}
\hypertarget{index_autotoc_md29}{}\doxysection{\texorpdfstring{10. References}{10. References}}\label{index_autotoc_md29}
\mbox{[}1\mbox{]} T. Li, M. Xu, R. Tang, Y. Chen, and Q. Xing, \href{https://arxiv.org/abs/2006.13125}{\texttt{ “\+Deep\+QTMT\+: A Deep Learning Approach for Fast QTMT-\/\+Based CU Partition of Intra-\/\+Mode VVC,”}} IEEE Transactions on Image Processing, vol. 30, pp. 5377–5390, 2021, doi\+: 10.\+1109/tip.2021.\+3083447. \mbox{[}2\mbox{]} R. K. Viana, “\+Deep learning architecture for fast intra-\/mode CUs partitioning in VVC,” Universidade de Aveiro, Nov. 2022.

  

\+:)

  